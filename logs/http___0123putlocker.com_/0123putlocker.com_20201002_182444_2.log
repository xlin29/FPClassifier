~0x30b62ba20000
@?
!?
c-1:%Save:{Window}:"Object":%safe
!?
c-1:%Save:{Window}:"Function":%safe
!?
c-1:%Save:{Window}:"Array":%safe
!?
c-1:%Save:{Window}:"String":%safe
!?
c-1:%Save:{Window}:"RegExp":%safe
!?
c-1:%Save:{Window}:"Error":%safe
!?
c-1:%Save:{Window}:"JSON":{Object}
@"null"
!?
n-1:%CustomWrappableAdapter
$13:"":(function() { // Copyright (c) 2012 The Chromium Authors. All rights reserved.\x0a// Use of this source code is governed by a BSD-style license that can be\x0a// found in the LICENSE file.\x0a\x0a/**\x0a * Enum for WebDriver status codes.\x0a * @enum {number}\x0a */\x0avar StatusCode = {\x0a  STALE_ELEMENT_REFERENCE\: 10,\x0a  JAVA_SCRIPT_ERROR\: 17,\x0a};\x0a\x0a/**\x0a * Enum for node types.\x0a * @enum {number}\x0a */\x0avar NodeType = {\x0a  ELEMENT\: 1,\x0a  DOCUMENT\: 9,\x0a};\x0a\x0a/**\x0a * Dictionary key to use for holding an element ID.\x0a * @const\x0a * @type {string}\x0a */\x0avar ELEMENT_KEY = 'ELEMENT';\x0a\x0a/**\x0a * True if using W3C Element references.\x0a * @const\x0a * @type {boolean}\x0a */\x0avar w3cEnabled = false;\x0a\x0a/**\x0a * True if shadow dom is enabled.\x0a * @const\x0a * @type {boolean}\x0a */\x0avar SHADOW_DOM_ENABLED = typeof ShadowRoot === 'function';\x0a\x0a/**\x0a * Generates a unique ID to identify an element.\x0a * @void\x0a * @return {string} Randomly generated ID.\x0a */\x0afunction generateUUID() {\x0a  var array = new Uint8Array(16);\x0a  window.crypto.getRandomValues(array);\x0a  array[6] = 0x40 | (array[6] & 0x0f);\x0a  array[8] = 0x80 | (array[8] & 0x3f);\x0a\x0a  var UUID = "";\x0a  for (var i = 0; i < 16; i++) {\x0a    var temp = array[i].toString(16);\x0a    if (temp.length < 2)\x0a      temp = "0" + temp;\x0a    UUID += temp;\x0a    if (i == 3 || i == 5 || i == 7 || i == 9)\x0a      UUID += "-";\x0a  }\x0a  return UUID;\x0a};\x0a\x0a/**\x0a * A cache which maps IDs <-> cached objects for the purpose of identifying\x0a * a script object remotely. Uses UUIDs for identification.\x0a * @constructor\x0a */\x0afunction CacheWithUUID() {\x0a  this.cache_ = {};\x0a}\x0a\x0aCacheWithUUID.prototype = {\x0a  /**\x0a   * Stores a given item in the cache and returns a unique UUID.\x0a   *\x0a   * @param {!Object} item The item to store in the cache.\x0a   * @return {number} The UUID for the cached item.\x0a   */\x0a  storeItem\: function(item) {\x0a    for (var i in this.cache_) {\x0a      if (item == this.cache_[i])\x0a        return i;\x0a    }\x0a    var id = generateUUID();\x0a    this.cache_[id] = item;\x0a    return id;\x0a  },\x0a\x0a  /**\x0a   * Retrieves the cached object for the given ID.\x0a   *\x0a   * @param {number} id The ID for the cached item to retrieve.\x0a   * @return {!Object} The retrieved item.\x0a   */\x0a  retrieveItem\: function(id) {\x0a    var item = this.cache_[id];\x0a    if (item)\x0a      return item;\x0a    var error = new Error('not in cache');\x0a    error.code = StatusCode.STALE_ELEMENT_REFERENCE;\x0a    error.message = 'element is not attached to the page document';\x0a    throw error;\x0a  },\x0a\x0a  /**\x0a   * Clears stale items from the cache.\x0a   */\x0a  clearStale\: function() {\x0a    for (var id in this.cache_) {\x0a      var node = this.cache_[id];\x0a      if (!this.isNodeReachable_(node))\x0a        delete this.cache_[id];\x0a    }\x0a  },\x0a\x0a  /**\x0a    * @private\x0a    * @param {!Node} node The node to check.\x0a    * @return {boolean} If the nodes is reachable.\x0a    */\x0a  isNodeReachable_\: function(node) {\x0a    var nodeRoot = getNodeRootThroughAnyShadows(node);\x0a    return (nodeRoot == document);\x0a  }\x0a\x0a\x0a};\x0a\x0a/**\x0a * A cache which maps IDs <-> cached objects for the purpose of identifying\x0a * a script object remotely.\x0a * @constructor\x0a */\x0afunction Cache() {\x0a  this.cache_ = {};\x0a  this.nextId_ = 1;\x0a  this.idPrefix_ = Math.random().toString();\x0a}\x0a\x0aCache.prototype = {\x0a\x0a  /**\x0a   * Stores a given item in the cache and returns a unique ID.\x0a   *\x0a   * @param {!Object} item The item to store in the cache.\x0a   * @return {number} The ID for the cached item.\x0a   */\x0a  storeItem\: function(item) {\x0a    for (var i in this.cache_) {\x0a      if (item == this.cache_[i])\x0a        return i;\x0a    }\x0a    var id = this.idPrefix_  + '-' + this.nextId_;\x0a    this.cache_[id] = item;\x0a    this.nextId_++;\x0a    return id;\x0a  },\x0a\x0a  /**\x0a   * Retrieves the cached object for the given ID.\x0a   *\x0a   * @param {number} id The ID for the cached item to retrieve.\x0a   * @return {!Object} The retrieved item.\x0a   */\x0a  retrieveItem\: function(id) {\x0a    var item = this.cache_[id];\x0a    if (item)\x0a      return item;\x0a    var error = new Error('not in cache');\x0a    error.code = StatusCode.STALE_ELEMENT_REFERENCE;\x0a    error.message = 'element is not attached to the page document';\x0a    throw error;\x0a  },\x0a\x0a  /**\x0a   * Clears stale items from the cache.\x0a   */\x0a  clearStale\: function() {\x0a    for (var id in this.cache_) {\x0a      var node = this.cache_[id];\x0a      if (!this.isNodeReachable_(node))\x0a        delete this.cache_[id];\x0a    }\x0a  },\x0a\x0a  /**\x0a    * @private\x0a    * @param {!Node} node The node to check.\x0a    * @return {boolean} If the nodes is reachable.\x0a    */\x0a  isNodeReachable_\: function(node) {\x0a    var nodeRoot = getNodeRootThroughAnyShadows(node);\x0a    return (nodeRoot == document);\x0a  }\x0a};\x0a\x0a/**\x0a * Returns the root element of the node.  Found by traversing parentNodes until\x0a * a node with no parent is found.  This node is considered the root.\x0a * @param {?Node} node The node to find the root element for.\x0a * @return {?Node} The root node.\x0a */\x0afunction getNodeRoot(node) {\x0a  while (node && node.parentNode) {\x0a    node = node.parentNode;\x0a  }\x0a  return node;\x0a}\x0a\x0a/**\x0a * Returns the root element of the node, jumping up through shadow roots if\x0a * any are found.\x0a */\x0afunction getNodeRootThroughAnyShadows(node) {\x0a  var root = getNodeRoot(node);\x0a  while (SHADOW_DOM_ENABLED && root instanceof ShadowRoot) {\x0a    root = getNodeRoot(root.host);\x0a  }\x0a  return root;\x0a}\x0a\x0a/**\x0a * Returns the global object cache for the page.\x0a * @param {Document=} opt_doc The document whose cache to retrieve. Defaults to\x0a *     the current document.\x0a * @return {!Cache} The page's object cache.\x0a */\x0afunction getPageCache(opt_doc, opt_w3c) {\x0a  var doc = opt_doc || document;\x0a  var w3c = opt_w3c || false;\x0a  // |key| is a long random string, unlikely to conflict with anything else.\x0a  var key = '$cdc_asdjflasutopfhvcZLmcfl_';\x0a  if (w3c) {\x0a    if (!(key in doc))\x0a      doc[key] = new CacheWithUUID();\x0a    return doc[key];\x0a  } else {\x0a    if (!(key in doc))\x0a      doc[key] = new Cache();\x0a    return doc[key];\x0a  }\x0a}\x0a\x0a/**\x0a * Wraps the given value to be transmitted remotely by converting\x0a * appropriate objects to cached object IDs.\x0a *\x0a * @param {*} value The value to wrap.\x0a * @return {*} The wrapped value.\x0a */\x0afunction wrap(value) {\x0a  // As of crrev.com/1316933002, typeof() for some elements will return\x0a  // 'function', not 'object'. So we need to check for both non-null objects, as\x0a  // well Elements that also happen to be callable functions (e.g. <embed> and\x0a  // <object> elements). Note that we can not use |value instanceof Object| here\x0a  // since this does not work with frames/iframes, for example\x0a  // frames[0].document.body instanceof Object == false even though\x0a  // typeof(frames[0].document.body) == 'object'.\x0a  if ((typeof(value) == 'object' && value != null) ||\x0a      (value instanceof HTMLAllCollection) ||\x0a      (typeof(value) == 'function' && value.nodeName &&\x0a       value.nodeType == NodeType.ELEMENT)) {\x0a    var nodeType = value['nodeType'];\x0a    if (nodeType == NodeType.ELEMENT || nodeType == NodeType.DOCUMENT\x0a        || (SHADOW_DOM_ENABLED && value instanceof ShadowRoot)) {\x0a      var wrapped = {};\x0a      var root = getNodeRootThroughAnyShadows(value);\x0a      wrapped[ELEMENT_KEY] = getPageCache(root, w3cEnabled).storeItem(value);\x0a      return wrapped;\x0a    }\x0a\x0a    var obj;\x0a    if (typeof(value.length) == 'number') {\x0a      obj = [];\x0a      for (var i = 0; i < value.length; i++)\x0a        obj[i] = wrap(value[i]);\x0a    } else {\x0a      obj = {};\x0a      for (var prop in value)\x0a        obj[prop] = wrap(value[prop]);\x0a    }\x0a    return obj;\x0a  }\x0a  return value;\x0a}\x0a\x0a/**\x0a * Unwraps the given value by converting from object IDs to the cached\x0a * objects.\x0a *\x0a * @param {*} value The value to unwrap.\x0a * @param {Cache} cache The cache to retrieve wrapped elements from.\x0a * @return {*} The unwrapped value.\x0a */\x0afunction unwrap(value, cache) {\x0a  if (typeof(value) == 'object' && value != null) {\x0a    if (ELEMENT_KEY in value)\x0a      return cache.retrieveItem(value[ELEMENT_KEY]);\x0a\x0a    var obj;\x0a    if (typeof(value.length) == 'number') {\x0a      obj = [];\x0a      for (var i = 0; i < value.length; i++)\x0a        obj[i] = unwrap(value[i], cache);\x0a    } else {\x0a      obj = {};\x0a      for (var prop in value)\x0a        obj[prop] = unwrap(value[prop], cache);\x0a    }\x0a    return obj;\x0a  }\x0a  return value;\x0a}\x0a\x0a/**\x0a * Calls a given function and returns its value.\x0a *\x0a * The inputs to and outputs of the function will be unwrapped and wrapped\x0a * respectively, unless otherwise specified. This wrapping involves converting\x0a * between cached object reference IDs and actual JS objects. The cache will\x0a * automatically be pruned each call to remove stale references.\x0a *\x0a * @param {function(...[*]) \: *} func The function to invoke.\x0a * @param {!Array<*>} args The array of arguments to supply to the function,\x0a *     which will be unwrapped before invoking the function.\x0a * @param {boolean} w3c Whether to return a W3C compliant element reference.\x0a * @param {boolean=} opt_unwrappedReturn Whether the function's return value\x0a *     should be left unwrapped.\x0a * @return {*} An object containing a status and value property, where status\x0a *     is a WebDriver status code and value is the wrapped value. If an\x0a *     unwrapped return was specified, this will be the function's pure return\x0a *     value.\x0a */\x0afunction callFunction(func, args, w3c, opt_unwrappedReturn) {\x0a  if (w3c) {\x0a    w3cEnabled = true;\x0a    ELEMENT_KEY = 'element-6066-11e4-a52e-4f735466cecf';\x0a\x0a  }\x0a  var cache = getPageCache(null, w3cEnabled);\x0a  cache.clearStale();\x0a\x0a  if (opt_unwrappedReturn)\x0a    return func.apply(null, unwrap(args, cache));\x0a\x0a  var status = 0;\x0a  try {\x0a    var returnValue = wrap(func.apply(null, unwrap(args, cache)));\x0a  } catch (error) {\x0a    status = error.code || StatusCode.JAVA_SCRIPT_ERROR;\x0a    var returnValue = error.message;\x0a  }\x0a  return {\x0a      status\: status,\x0a      value\: returnValue\x0a  }\x0a}\x0a; return callFunction.apply(null, arguments) }\x0a).apply(null, [function(s) { return 1; }, [], true])
!13
g5716:{HTMLDocument}:"$cdc_asdjflasutopfhvcZLmcfl_"
$15:"":var frame = document.createElement('iframe');frame.name = 'chromedriver dummy frame';frame.src = 'about\:blank';document.body.appendChild(frame);window.setTimeout(function() {  document.body.removeChild(frame);}, 0);
!15
g21:{HTMLDocument}:"createElement"
c21:%createElement:{HTMLDocument}:"iframe"
n21:%HTMLIFrameElement
c56:?:{HTMLIFrameElement}:"chromedriver dummy frame"
c95:?:{HTMLIFrameElement}:"about\:blank"
g120:{HTMLDocument}:"body"
c120:?:{HTMLDocument}
n120:%HTMLBodyElement
g125:{HTMLBodyElement}:"appendChild"
c125:%appendChild:{HTMLBodyElement}:{HTMLIFrameElement}
@?
c125:%Save:{Window}:"Object":%safe
c125:%Save:{Window}:"Function":%safe
c125:%Save:{Window}:"Array":%safe
c125:%Save:{Window}:"String":%safe
c125:%Save:{Window}:"RegExp":%safe
c125:%Save:{Window}:"Error":%safe
c125:%Save:{Window}:"JSON":{Object}
@"null"
n125:%CustomWrappableAdapter
g151:{Window}:"setTimeout"
c151:%setTimeout:{Window}:<anonymous>:0
g185:{HTMLDocument}:"body"
c185:?:{HTMLDocument}
g190:{HTMLBodyElement}:"removeChild"
c190:%removeChild:{HTMLBodyElement}:{HTMLIFrameElement}
